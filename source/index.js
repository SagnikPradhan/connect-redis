"use strict";Object.defineProperty(exports,"__esModule",{value:true});const isNodeRedis=client=>"SCAN"in client;function __attach(callback){return promise=>{promise.then(value=>callback(undefined,value)).catch(error=>callback(error))}}const noop=()=>{};function connectRedis({Store}){return class RedisStore extends Store{prefix;client;serializer;disableTTL;ttl;disableTouch;constructor({options,client,prefix,serializer,disableTTL,ttl,disableTouch}){super(options);this.client=client;this.prefix=typeof prefix==="string"?prefix:"sess:";this.serializer=serializer||JSON;this.disableTTL=disableTTL||false;this.ttl=ttl||24*60*60;this.disableTouch=disableTouch||false}get(sid,callback){const main=async()=>{const key=`${this.prefix}${sid}`;const value=await this.__sendCommand("GET",key);if(value)return this.serializer.parse(value);else return null};__attach(callback)(main())}set(sid,session,callback=noop){const main=async()=>{const key=`${this.prefix}${sid}`;const value=this.serializer.stringify(session);if(this.disableTTL)return this.__sendCommand("SET",key,value);const ttl=this.__getTTL(session);if(ttl<0)return this.__sendCommand("DEL",key);return this.__sendCommand("SET",key,value,"EX",ttl.toString())};__attach(callback)(main().then(()=>undefined))}destroy(sid,callback=noop){const key=`${this.prefix}${sid}`;__attach(callback)(this.__sendCommand("DEL",key).then(()=>undefined))}touch(sid,session,callback=noop){const main=async()=>{if(this.disableTTL||this.disableTouch)return undefined;const key=`${this.prefix}${sid}`;await this.__sendCommand("EXPIRE",key,this.__getTTL(session).toString())};__attach(callback)(main())}clear(callback=noop){__attach(callback)(this.__getAllKeys().then(keys=>void this.__sendCommand("DEL",...keys)))}length(callback){__attach(callback)(this.__getAllKeys().then(value=>value.length))}ids(callback){__attach(callback)(this.__getAllKeys().then(keys=>keys.map(k=>k.slice(this.prefix.length))))}all(callback){const main=async()=>{const keys=await this.__getAllKeys();const values=await this.__sendCommand("MGET",...keys);return Object.fromEntries(keys.map((key,idx)=>{const value=values[idx];return[key.slice(this.prefix.length),this.serializer.parse(value),]}))};__attach(callback)(main())}__getTTL(session){var ref;return(session===null||session===void 0?void 0:(ref=session.cookie)===null||ref===void 0?void 0:ref.expires)?Math.ceil((Number(session.cookie.expires)-Date.now())/1e3):this.ttl}__getAllKeys(){const escapedPrefix=this.prefix.replace(/\\/g,"\\\\").replace(/\*/g,"\\*").replace(/\?/g,"\\?").replace(/\[/g,"\\[").replace(/\]/g,"\\]").replace(/\{/g,"\\{").replace(/\}/g,"\\}").replace(/\)/g,"\\)").replace(/\(/g,"\\(").replace(/\!/g,"\\!");const pattern=`${escapedPrefix}*`;return this.__scanKeys(0,pattern,100)}async __scanKeys(cursor1,pattern,count){const[nextCursor,keys1]=await this.__sendCommand("SCAN",cursor1.toString(),"MATCH",pattern,"COUNT",count.toString()).then(([cursor,keys])=>[Number(cursor),keys.map(String)]);return[...keys1,...nextCursor!==0?await this.__scanKeys(nextCursor,pattern,count):[],]}__sendCommand(...[cmd,...args]){return new Promise(resolve=>{if(isNodeRedis(this.client))resolve(this.client.sendCommand([cmd,...args],{}));else{const ioRedis=require("ioredis");const redisCommand=new ioRedis.Command(cmd,args);resolve(redisCommand.promise);this.client.sendCommand(redisCommand)}})}}}exports.__attach=__attach;exports.connectRedis=connectRedis
//# sourceMappingURL=index.js.map
