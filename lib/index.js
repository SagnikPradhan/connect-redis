"use strict";var redis=require("redis");function _interopDefaultLegacy(e){return e&& typeof e==="object"&&"default"in e?e:{"default":e}}var redis__default=_interopDefaultLegacy(redis);const x=redis__default["default"].createClient();x.scan(1,{}).then();const isNodeRedis=client=>"SCAN"in client;function callbackify(fn){return(...args)=>{const callback=typeof args[args.length-1]==="function"?args.pop():()=>undefined;fn(...args).then(value=>callback(undefined,value)).catch(error=>callback(error,undefined))}}function connectRedis({Store}){return class RedisStore extends Store{prefix;client;serializer;disableTTL;ttl;disableTouch;constructor({options,client,prefix,serializer,disableTTL,ttl,disableTouch}){super(options);this.client=client;this.prefix=prefix||"sess:";this.serializer=serializer||JSON;this.disableTTL=disableTTL||false;this.ttl=ttl||24*60*60;this.disableTouch=disableTouch||false;this.get=callbackify(this.getAsync);this.set=callbackify(this.setAsync);this.destroy=callbackify(this.destroyAsync);this.all=callbackify(this.allAsync);this.length=callbackify(this.lengthAsync);this.clear=callbackify(this.clearAsync);this.touch=callbackify(this.touchAsync)}async getAsync(sid){const key=`${this.prefix}${sid}`;const value=await this.client.get(key);if(!value)return null;return this.serializer.parse(value)}async setAsync(sid,session){const key=`${this.prefix}${sid}`;const value=this.serializer.stringify(session);const ttl=this.__getTTL(session);if(ttl<0&&!this.disableTTL)return this.destroyAsync(sid);if(this.disableTTL)this.client.set(key,value);else if(isNodeRedis(this.client))await this.client.set(key,value,{EX:ttl});else await this.client.set(key,value,"EX",ttl)}async destroyAsync(sid){const key=`${this.prefix}${sid}`;await this.client.del(key)}async touchAsync(sid,session){if(this.disableTouch||this.disableTouch)return;const key=`${this.prefix}${sid}`;await this.client.expire(key,this.__getTTL(session))}async clearAsync(){await this.client.del(await this.__getAllKeys())}async lengthAsync(){return(await this.__getAllKeys()).length}async idsAsync(){return await this.__getAllKeys().then(key=>key.slice(this.prefix.length))}async allAsync(){const keys=await this.__getAllKeys();const values=isNodeRedis(this.client)?await this.client.mGet(keys):await this.client.mget(keys);return Object.fromEntries(keys.map((key,idx)=>{const value=values[idx];if(value)return[key.slice(this.prefix.length),this.serializer.parse(value),];else return null}).filter(value=>Boolean(value)))}__getTTL(session){var ref;return(session===null||session===void 0?void 0:(ref=session.cookie)===null||ref===void 0?void 0:ref.expires)?Math.ceil((Number(session.cookie.expires)-Date.now())/1e3):this.ttl}async __getAllKeys(){const pattern=`${this.prefix}*`;return this.__scanKeys(0,pattern,100)}async __scanKeys(cursor1,pattern,count){const{cursor:nextCursor,keys:keys1}=await (isNodeRedis(this.client)?this.client.scan(cursor1,{COUNT:count,MATCH:pattern}):this.client.scan(cursor1,"MATCH",pattern,"COUNT",count).then(([cursor,keys])=>({cursor:Number(cursor),keys})));return[...keys1,...nextCursor!==0?await this.__scanKeys(nextCursor,pattern,count):[],]}}}module.exports=connectRedis
